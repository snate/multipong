\section{Multipong} % TODO: Better title?

In this section we will describe how we developed the Multipong application,
focusing on some architectural and implementation choices we made to improve
the game quality.

\subsection{Game description} % TODO: Better title?

Multipong is a tribute to the Pong game, one of the first arcade videogames.
Instead of playing against an AI, there are a single-player mode and a
multiplayer mode.

In the single-player mode the player scores a point each time the paddle hits
the ball, making it bounce upwards until it reaches the top edge and then the
ball falls down again. Clearly, the player loses the game when the paddle misses
the ball.

In the multiplayer mode, several human players connect their devices in order
to form an ad hoc network and then when one of the players hits the ball, it is
transferred to the next player's screen as if their gameboards were joint.
When a player misses the ball, he loses a life and the ball is thrown out
randomly to the next player's screen.
If a player runs out of lives, she will not be able to play for the rest of the
game.

Before starting a multiplayer game a player (called the \textit{host}) creates
a match, allowing other players in his same network to join. Then, when the
game starts, the host will be the initial player.

Since the single-player mode does not involve any significant discussion about
networking and that we did not put any special effort into making the game save
more battery power by optimizing the ui rendering (e.g. we could have improved
the ui rendering performance by using OpenGL), here below we will focus on
discussing the two phases of the multiplayer mode, namely the game formation
and the gameplay.

\subsection{Game formation}

Hereafter we will assume that the players configured correctly a Wi-Fi Direct
ad hoc network with their Android devices, i.e. that they can communicate with
each other within this network.

Since in this phase there are not strong requirements to meet in terms of
real-time information delivering, we decided to use TCP connections until the
game starts. Also, this choice will provide us an element of comparison to the
solution we adopted for gameplay.
Raw data sent over sockets is formatted as JSON objects, so that we are able to
distinguish more easily the requests from one peer to another.

All the design was built having in mind that the topology underneath our system
is an $1:n$ P2P network, so even if the game formation carries out having one
host and several participants, we can not enforce the fact that the host will
also be the GO. Besides this, during the discovery phase only the NGOs will
obtain an address to the GO (and it will be equal to \texttt{192.168.49.1}),
whereas the GO will be notified only of the \textit{presence} of peers, without
obtaining any concrete reference to communicate to them. This means that the
networking logic present in our application have to take into account the fact
that the GO needs to retrieve somehow the IPs of the NGOs.

Before describing the protocols we employed for the game formation phase, we
want to briefly describe how we have implemented data exchange between peers.
Each peer has two threads, respectively for receiving and sending data via the
network. The communication is performed in an asynchronous fashion, so that
messages can be exchanged without blocking on response. However, we implemented
also the semantics for synchronizing on certain operations and we guarantee FIFO
ordering for the data sent out of a device.

In order to create a match among several players, applications on different
devices have to follow a protocol. Firstly, at Wi-Fi P2P discovery time, new
NGOs have to ask to the GO if the application which is running on it is hosting
a game or not by means of a \texttt{ARE\_YOU\_THE\_HOST} message. If so, the
host replies with a \texttt{TELL\_IP} message, otherwise this peer (which is
therefore a participant) replies with a \texttt{KNOWN\_HOSTS} message, in which
the GO lists the hosts it knows.

Then the participant surely knows the IP of a host (if any) and it is able to
send a \texttt{DISCOVERY} message to the host. This message causes the host to
reply with an \texttt{AVAILABLE} message in which currently joined players are
listed. After this step, the participant can join the message by sending a
\texttt{JOIN} message to the host, receiving back an \texttt{AVAILABLE} message
in which she will be present as a confirmation. Finally, a player can cancel
her subscription by sending a \texttt{CANCEL} message and receiving back an
\texttt{AVAILABLE} message in which she will not be present anymore.

When a host player sees more than one participant in its match list, she can
decide to start a game, making her Multipong app send a \texttt{STARTING}
message to all of the game participants. Since this is a blocking operation
because it is better not to start the game until all the other players' games
started, the host has to wait for all the messages in its sending queue to be
sent before starting. If some player is unreachable for some reason
during the game starting, she will be excluded by the match as described in
the following subsection.

\subsection{Gameplay}

% TODO: application level acked UDP
% TODO: two layers of abstraction 
% TODO: describe the protocol of gameplay
% TODO: fault tolerance
% TODO: describe the difference between GO and NGO failures
